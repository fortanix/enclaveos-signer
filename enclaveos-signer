#!/usr/bin/env python3


from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.serialization import load_der_public_key, load_pem_private_key
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicKey
from cryptography.hazmat.primitives import hashes

from sdkms.v1 import (configuration, ApiClient, ApprovalRequestsApi, AuthenticationApi, PluginsApi,
                      SecurityObjectsApi, SignAndVerifyApi, SignRequest, SobjectDescriptor,
                      SobjectRequest)
from sdkms.v1.models import ApprovalRequestRequest, ApprovalStatus, DigestAlgorithm, ObjectType
from sdkms.v1.rest import ApiException

import argparse
import base64
import binascii
import datetime
import docker
import hashlib
import io
import os
import re
import shutil
import struct
import subprocess
import sys
import tarfile
import tempfile
import time


__version__ = "1.20.devel"

# Check docker version
if not docker.__version__.startswith('4.0'):
    raise ImportError('Wrong python version. This machine has: docker=={}, when docker==4.0.x is required.' \
                        .format(docker.__version__))

""" Default / Architectural Options """

ARCHITECTURE = "amd64"

PAGESIZE = 4096
MEMORY_GAP = PAGESIZE

TCSSIZE = PAGESIZE

# We may need to support larger SSA sizes for future CPUs. ZIRC-2136.
SSAFRAMESIZE = PAGESIZE
SSAFRAMENUM = 2

MEMORY_MODEL_FULL = 'full'
MEMORY_MODEL_MINIMAL = 'minimal'

VALID_MEMORY_MODELS = [ MEMORY_MODEL_FULL, MEMORY_MODEL_MINIMAL ]

ENCLAVE_STACK_SIZE = PAGESIZE * 16
DEFAULT_ENCLAVE_SIZE = '256M'
DEFAULT_THREAD_NUM = 4
DEFAULT_MEMORY_MODEL = MEMORY_MODEL_FULL
ENCLAVE_HEAP_MIN = 0x10000

DEFAULT_FORTANIX_API_ENDPOINT = 'https://api.amer.smartkey.io'

# This size must match the architecturally-defined sgx_arch_gpr_t in sgx-arch.h.
SGX_ARCH_GPR_SIZE = 184

verbose = False

# If you need to debug what's getting hashed, you can set mrenclave_debug to True and the signer will produce
# /tmp/mrenclave.signer with all of the input data.
mrenclave_debug = False

# This is from tools/converter/app/builder.py
IMAGE_REGEX = re.compile('^((?:[a-zA-Z0-9-.]+(?::[0-9]+)?/)?(?:[a-zA-Z0-9-_/]+))(?::([a-zA-Z0-9-._]+))?$')

""" Utilities """

def debug_print(*argv):
    if verbose:
        print(*argv, file=sys.stderr)

def roundup(addr):
    remaining = addr % PAGESIZE
    if remaining:
        return addr + (PAGESIZE - remaining)
    else:
        return addr

def rounddown(addr):
    return addr - addr % PAGESIZE

def roundup_data(data):
    return data + '\0' * (roundup(len(data)) - len(data))

def parse_int(s):
    if len(s) > 2 and s.startswith("0x"):
        return int(s[2:], 16)
    if len(s) > 1 and s.startswith("0"):
        return int(s[1:], 8)
    return int(s)

def parse_size(s):
    scale = 1
    if s.endswith("K"):
        scale = 1024
    if s.endswith("M"):
        scale = 1024 * 1024
    if s.endswith("G"):
        scale = 1024 * 1024 * 1024
    if scale != 1:
        s = s[:-1]
    return parse_int(s) * scale

def unsigned_short(inp):
    res = int(inp)
    if res < 0 or res >= pow(2,16):
         raise argparse.ArgumentTypeError("%s should be between 0 and 2^16 -1" % res)
    return res

""" Reading / Writing Manifests """

def read_manifest(filename):
    manifest = {}
    manifest_layout = []
    with open(filename, "r") as f:
        for line in f.readlines():
            if line == "":
                manifest_layout.append((None, None))
                break

            pound = line.find("#")
            if pound != -1:
                comment = line[pound:].strip()
                line = line[:pound]
            else:
                comment = None

            line = line.strip()
            equal = line.find("=")
            if equal != -1:
                key = line[:equal].strip()
                manifest[key] = line[equal + 1:].strip()
            else:
                key = None

            manifest_layout.append((key, comment))

    return (manifest, manifest_layout)

def output_manifest(filename, manifest, manifest_layout):
    with open(filename, 'w') as f:
        written = []

        for (key, comment) in manifest_layout:
            line = ''
            if key is not None:
                line += key + ' = ' + manifest[key]
                written.append(key)
            if comment is not None:
                if line != '':
                    line += ' '
                line += comment
            print(line, file=f)

        print("\n# Generated by {}\n".format("enclaveos-signer"), file=f)

        for key in sorted(manifest.keys()):
            if key not in written:
                print(key, '=', manifest[key], file=f)


""" Loading Enclave Attributes """

def get_enclave_attributes(cmdline_args):

    # TODO: ZIRC-3455 - move constants to C header file

    # Flags of the ATTRIBUTES Structure used in the SECS, REPORT,
    # KEYREQUEST and SIGSTRUCT structures.
    # Reference: Table 37-3 and 37-21 of the Intel 64 & IA-32 architectures
    # software developer's manual vol 3. 2020 Edition.
    FLAGS_INIT           = 0x01
    FLAGS_DEBUG          = 0x02
    FLAGS_MODE64BIT      = 0x04
    # Bit 3 is reserved and set in FLAGS_RESERVED
    FLAGS_PROVISIONKEY   = 0x10
    FLAGS_EINITTOKEN_KEY = 0x20
    FLAGS_CET            = 0x40
    FLAGS_KSS            = 0x80
    FLAGS_RESERVED       = 0xFFFFFFFFFFFFFF08

    # Flags used by the XSAVE Feature Request Mask (XFRM) of the ATTRIBUTES
    # Structure to execute additional instructions
    # Reference: Section 2.6 and 41.7.2.1

    # To enable the use of features like AVX, MPX and AVX-512 a combination
    # of bits need to be set based on it's dependency and the registers
    # used by each feature set.
    # Failing to adhere to these dependencies causes an exception
    XFRM_FPU_MMX  = 0x01
    XFRM_SSE      = 0x02
    XFRM_LEGACY   = XFRM_FPU_MMX | XFRM_SSE # Mandatory for SGX

    # AVX requires SSE, and AVX-512 requires AVX. Zircon currently requires that the CPU have at least
    # AVX. AVX-512 will be enabled if the CPU we're running on supports it, but is not required. Currently,
    # AVX-512 is the only feature that we optionally enable. We should also support running on CPUs that
    # don't have AVX, but that requires additional changes in zircon. ZIRC-4061. These constants only include
    # the bits associated with the named feature (AVX or AVX-512), so we can construct masks that include or
    # exclude the bits for just that feature.
    XFRM_AVX      = 0x04
    XFRM_AVX_512  = 0xE0
    XFRM_MPX      = 0x18
    XFRM_RESERVED = 0xFFFFFFFFFFFFFC00

    # Flags of the MISCSELECT field to set the Extended SSA frame features
    # to be used
    # Reference: Section 37.7.2, Table 37-4
    MISCS_EXINFO   = 0x1
    MISCS_CPINFO   = 0x2
    MISCS_RESERVED = 0xFFFFFFFC

    attributes = FLAGS_DEBUG | FLAGS_MODE64BIT
    xfrms      = XFRM_LEGACY | XFRM_AVX

    # Remove DEBUG from attributes, but not from attribute_mask.
    if cmdline_args.production:
        attributes = attributes & ~FLAGS_DEBUG

    # The attribute mask contains all bits set. This is similar to what the Intel SGX SDK for Linux seems to do.
    # (They actually clear the 64-bit mask bit, since they support loading 32 and 64 bit enclaves). The bottom bit
    # is the INIT bit. We used to clear this bit. We suspect that clearing this mask bit causes EINIT to fail with an
    # SGX_INVALID_ATTRIBUTE error on some CPUs, so we set it now. ZIRC-4384.
    attribute_mask = 0xFFFFFFFFFFFFFFFF

    # xfrms_mask is the mask of bits that must match when the enclave runs. For bits that are 1 in xfrm_mask,
    # the corresponding bit in xfrm must be the same when the signature was created and when the enclave is run.
    # For bits that are 0, the corresponding bit in xfrm can differ when the enclave is run compared to what
    # it was when the signature was signed. This allows some bits to be enforced and some bits to be not enforced.
    #
    # The enclave loader must also support optionally enabling any XFRM bits that are made optional here.
    # See UrtsEnableOptionalFeatures() in urts-framework.c.
    #
    # Changing xfrms_mask also requires changing various tests under pal/src/sgx/signer/tests.
    xfrms_mask     = 0xFFFFFFFFFFFFFFFF & ~(XFRM_AVX_512)

    miscs = 0
    miscs_mask = 0xFFFFFFFF & ~(MISCS_EXINFO)

    attributes_raw     = struct.pack("<Q", attributes)
    xfrms_raw          = struct.pack("<Q", xfrms)
    attribute_mask_raw = struct.pack("<Q", attribute_mask)
    xfrms_mask_raw     = struct.pack("<Q", xfrms_mask)
    miscs_raw          = struct.pack("<L", miscs)
    miscs_mask_raw     = struct.pack("<L", miscs_mask)

    debug_print("Attributes:")
    debug_print("    attributes:     %016x" % (int.from_bytes(attributes_raw, byteorder='big')))
    debug_print("    attribute mask: %016x" % (int.from_bytes(attribute_mask_raw, byteorder='big')))
    debug_print("    xfrms:          %016x" % (int.from_bytes(xfrms_raw, byteorder='big')))
    debug_print("    xfrms mask:     %016x" % (int.from_bytes(xfrms_mask_raw, byteorder='big')))
    debug_print("    miscselect:     %08x" % (int.from_bytes(miscs_raw, byteorder='big')))
    debug_print("    miscs mask:     %08x" % (int.from_bytes(miscs_mask_raw, byteorder='big')))

    return (attributes_raw, attribute_mask_raw, xfrms_raw, xfrms_mask_raw,
            miscs_raw, miscs_mask_raw)

""" Populate Enclave Memory """

PAGEINFO_R = 0x1
PAGEINFO_W = 0x2
PAGEINFO_X = 0x4
PAGEINFO_TCS = 0x100
PAGEINFO_REG = 0x200

def get_loadcmds(filename):
    loadcmds = []
    # This can hang. ZIRC-2003.
    p = subprocess.Popen(['/usr/bin/readelf', '-l', '-W', filename],
                         stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    while True:
        line = p.stdout.readline().decode('utf-8')
        if line == '':
            break
        stripped = line.strip()
        if not stripped.startswith('LOAD'):
            continue
        tokens = stripped.split()
        if len(tokens) < 6:
            continue
        if len(tokens) >= 7 and tokens[7] == "E":
            tokens[6] += tokens[7]
        prot = 0
        for t in tokens[6]:
            if t == "R":
                prot = prot | 4
            if t == "W":
                prot = prot | 2
            if t == "E":
                prot = prot | 1

        loadcmds.append((int(tokens[1][2:], 16),  # offset
                         int(tokens[2][2:], 16),  # addr
                         int(tokens[4][2:], 16),  # filesize
                         int(tokens[5][2:], 16),  # memsize
                         prot))
    p.wait()
    if p.returncode != 0:
        return None
    return loadcmds

# Returns a list of dynamic symbols in the data segment of an ELF file. Returns an array of tuples of the form
# (symbol_name, load_address, symbol_size)
def get_data_symbols(filename):
    data_symbols = []
    p = subprocess.Popen(['/usr/bin/objdump', '--section', '.data', '-T', filename],
                         stdout=subprocess.PIPE)
    while True:
        line = p.stdout.readline().decode('utf-8')
        if line == '':
            break
        stripped = line.strip()
        tokens = stripped.split()
        if len(tokens) < 7:
            continue
        data_symbols.append((tokens[6], int(tokens[0], 16), int(tokens[4], 16)))
    p.kill()
    p.wait()

    return data_symbols

def get_entry_point(filename):
    p = subprocess.Popen(['/usr/bin/readelf', '-h', filename],
                         stdout=subprocess.PIPE)
    while True:
        line = p.stdout.readline().decode('utf-8')
        if line == '':
            break
        stripped = line.strip()
        match = re.search('Entry point address:\s*(0x[0-9a-fA-F]+)', line)
        if match:
            entry = int(match.group(1), 0)
            p.kill()
            p.wait()
            return entry

    assert(0)

class MemoryArea(object):
    def __init__(self, desc, file=None, addr=None, size=None, flags=None, eextend=None, contents=None):
        self.desc = desc
        self.file = file
        self.addr = addr
        self.size = size
        self.flags = flags
        self.is_binary = False
        self.eextend = eextend
        self.contents = contents

        if file:
            loadcmds = get_loadcmds(file)
            if loadcmds:
                mapaddr = 0xffffffffffffffff
                mapaddr_end = 0
                for (offset, addr, filesize, memsize, prot) in loadcmds:
                    if rounddown(addr) < mapaddr:
                        mapaddr = rounddown(addr)
                    if roundup(addr + memsize) > mapaddr_end:
                        mapaddr_end = roundup(addr + memsize)

                self.is_binary = True
                self.size = mapaddr_end - mapaddr
                if mapaddr > 0:
                    self.addr = mapaddr
            else:
                self.size = os.stat(file).st_size

        if self.addr is not None:
            self.addr = rounddown(self.addr)
        if self.size is not None:
            self.size = roundup(self.size)

# Create the initial contents for the SGX TCS. This has to match sgx_arch_tcs_t in sgx-arch.h.
def create_tcs(ssa_base, tls_base, pal_code_base, enclave_entry, num_threads):
    layout = bytearray(num_threads * PAGESIZE)
    for t in range(num_threads):
        reserved = 0
        flags = 0
        nssa = SSAFRAMENUM
        cssa = 0
        ossa = ssa_base + t * nssa * SSAFRAMESIZE
        fsbase = 0
        gsbase = tls_base + t * PAGESIZE
        fslimit = 0xfff
        gslimit = 0xfff

        # enclave_entry is the offset relative to the PAL base, so we need to add the actual PAL load address.
        rebased_enclave_entry = pal_code_base + enclave_entry

        tcs = struct.pack('<QQQLLQQQQLL', reserved, flags, ossa, cssa, nssa, rebased_enclave_entry, reserved,
                          fsbase, gsbase, fslimit, gslimit)
        layout[0 + t * PAGESIZE : 72 + t * PAGESIZE] = tcs

    return layout

# Create initial contents for the enclave TLS pages. This has to match struct enclave_tls in enclave-tls.h.
def create_tls(tls_base, stacks, ssa_base, num_threads):
    layout = bytearray(num_threads * PAGESIZE)
    for t in range(num_threads):
        tls_self = tls_base + PAGESIZE * t
        initial_stack_top = stacks[t].addr + ENCLAVE_STACK_SIZE
        initial_stack_bottom = stacks[t].addr
        fsbase = 0
        ssaframesize = SSAFRAMESIZE
        ssa = ssa_base + ssaframesize * SSAFRAMENUM * t
        gpr = ssa + ssaframesize - SGX_ARCH_GPR_SIZE

        tls = struct.pack('<QQQQQQQ', tls_self, initial_stack_top, initial_stack_bottom, fsbase, ssaframesize, ssa, gpr)
        layout[0 + t * PAGESIZE : 56 + t * PAGESIZE] = tls
    return layout


def get_memory_areas(thread_num, libpal, vdso_path, shim_path):
    areas = []
    areas.append(MemoryArea('ssa', size=thread_num * SSAFRAMESIZE * SSAFRAMENUM,
                            flags=PAGEINFO_R|PAGEINFO_W|PAGEINFO_REG, eextend=True,
                            contents=bytes(thread_num * SSAFRAMESIZE * SSAFRAMENUM)))
    areas.append(MemoryArea('tcs', size=thread_num * TCSSIZE,
                            flags=PAGEINFO_TCS, eextend=True, contents=None))
    areas.append(MemoryArea('tls', size=thread_num * PAGESIZE,
                            flags=PAGEINFO_R|PAGEINFO_W|PAGEINFO_REG, eextend=True))

    stacks = []
    for t in range(thread_num):
        area = MemoryArea('stack', size=ENCLAVE_STACK_SIZE,
                          flags=PAGEINFO_R|PAGEINFO_W|PAGEINFO_REG, eextend=True,
                          contents=bytes(ENCLAVE_STACK_SIZE))
        areas.append(area)
        stacks.append(area)

    areas.append(MemoryArea('pal', file=libpal, flags=PAGEINFO_REG, eextend=True))

    if shim_path is not None:
        areas.append(MemoryArea('shim', file=shim_path, flags=PAGEINFO_REG, eextend=True))

    if vdso_path is not None:
        areas.append(MemoryArea('vdso', file=vdso_path, flags=PAGEINFO_REG, eextend=True))

    return (areas, stacks)

def populate_memory_areas(memory_model, enclave_size, areas):
    populating = enclave_size

    for area in areas:
        if area.addr is not None:
            continue

        area.addr = populating - area.size
        if area.addr < ENCLAVE_HEAP_MIN:
            raise Exception("Enclave size is not large enough")
        if area.desc == 'exec':
            populating = area.addr;
        else:
            populating = area.addr - MEMORY_GAP

    free_areas = []
    if memory_model == MEMORY_MODEL_FULL:
        for area in areas:
            if area.addr + area.size < populating:
                addr = area.addr + area.size
                free_areas.append(MemoryArea('free', addr=addr, size=populating - addr,
                                    flags=PAGEINFO_R|PAGEINFO_W|PAGEINFO_X|PAGEINFO_REG, eextend=False))
                populating = area.addr

        if populating > ENCLAVE_HEAP_MIN:
            free_areas.append(MemoryArea('free', addr=ENCLAVE_HEAP_MIN,
                                         size=populating - ENCLAVE_HEAP_MIN,
                                         flags=PAGEINFO_R|PAGEINFO_W|PAGEINFO_X|PAGEINFO_REG, eextend=False))

    return areas + free_areas

def generate_measurement(enclave_size, areas):

    def do_ecreate(digest, size):
        data = struct.pack("<8sLQ44s", b"ECREATE", SSAFRAMESIZE // PAGESIZE, size, b"")
        digest.update(data)

    def do_eadd(digest, offset, flags):
        data = struct.pack("<8sQQ40s", b"EADD", offset, flags, b"")
        digest.update(data)

    def do_eextend(digest, offset, payload):
        data = struct.pack("<8sQ48s", b"EEXTEND", offset, b"")
        digest.update(data)
        digest.update(payload)

    class mrenclave_digest(object):
        def __init__(self):
            self.digest = hashlib.sha256()
            if mrenclave_debug:
                self.debug_handle = open("/tmp/mrenclave.signer", "wb")
            else:
                self.debug_handle = None

        def update(self, payload):
            for er in range(0, len(payload), 64):
                self.digest.update(payload[er:er+64])

            if self.debug_handle:
                self.debug_handle.write(payload)

        def finalize(self):
            return self.digest.digest()

    mrenclave = mrenclave_digest()
    do_ecreate(mrenclave, enclave_size)

    def print_area(addr, size, flags, desc, measured):
        if flags & PAGEINFO_REG:
            type = 'REG'
        if flags & PAGEINFO_TCS:
            type = 'TCS'
        prot = ['-', '-', '-']
        if flags & PAGEINFO_R:
            prot[0] = 'R'
        if flags & PAGEINFO_W:
            prot[1] = 'W'
        if flags & PAGEINFO_X:
            prot[2] = 'X'
        prot = ''.join(prot)

        desc = '(' + desc + ')'
        if measured:
            desc += ' measured'

        if size == PAGESIZE:
            debug_print("    %016x [%s:%s] %s" % (addr, type, prot, desc))
        else:
            debug_print("    %016x-%016lx [%s:%s] %s" % (addr, addr + size, type, prot, desc))

    def load_file(digest, f, offset, addr, filesize, memsize, desc, flags):
        f_addr = rounddown(offset)
        m_addr = rounddown(addr)
        f_size = roundup(offset + filesize) - f_addr
        m_size = roundup(addr + memsize) - m_addr

        print_area(m_addr, f_size, flags, desc, True)
        if f_size < m_size:
            print_area(m_addr + f_size, m_size - f_size, flags, "bss", True)

        for pg in range(m_addr, m_addr + m_size, PAGESIZE):
            do_eadd(digest, pg, flags)

            for er in range(pg, pg + PAGESIZE, 256):
                start = er - m_addr + f_addr
                end = start + 256
                start_zero = b""
                if start < offset:
                    if offset - start >= 256:
                        start_zero = bytes(256)
                    else:
                        start_zero = bytes(offset - start)
                end_zero = b""
                if end > offset + filesize:
                    if end - offset - filesize >= 256:
                        end_zero = bytes(256)
                    else:
                        end_zero = bytes(end - offset - filesize)
                start += len(start_zero)
                end -= len(end_zero)
                if start < end:
                    f.seek(start)
                    data = f.read(end - start)
                else:
                    data = b""
                if len(start_zero + data + end_zero) != 256:
                    raise Exception("wrong calculation")
                payload = start_zero + data + end_zero
                do_eextend(digest, er, payload)

    for area in areas:
        if area.file:
            with open(area.file, 'rb') as f:
                if area.is_binary:
                    loadcmds = get_loadcmds(area.file)
                    if loadcmds:
                        mapaddr = 0xffffffffffffffff
                        for (offset, addr, filesize, memsize, prot) in loadcmds:
                            if rounddown(addr) < mapaddr:
                                mapaddr = rounddown(addr)
                    baseaddr = area.addr - mapaddr
                    for (offset, addr, filesize, memsize, prot) in loadcmds:
                        flags = area.flags
                        if prot & 4:
                            flags = flags | PAGEINFO_R
                        if prot & 2:
                            flags = flags | PAGEINFO_W
                        if prot & 1:
                            flags = flags | PAGEINFO_X

                        # All loadable segments need to be writable, so we can perform
                        # relocations. When we fix ZIRC-2013 and perform the relocations
                        # before the enclave is started, we can remove this extra write
                        # permission.
                        flags = flags | PAGEINFO_W

                        if flags & PAGEINFO_X:
                            desc = 'code'
                        else:
                            desc = 'data'
                        load_file(mrenclave, f, offset, baseaddr + addr,
                                  filesize, memsize, desc, flags)
                else:
                    load_file(mrenclave, f, 0, area.addr,
                              os.stat(area.file).st_size, area.size,
                              area.desc, area.flags)
        else:
            for a in range(area.addr, area.addr + area.size, PAGESIZE):
                do_eadd(mrenclave, a, area.flags)
                if area.eextend:
                    for er in range(a, a + PAGESIZE, 256):
                        do_eextend(mrenclave, er,
                                   area.contents[er - area.addr:er + 256 - area.addr])

            print_area(area.addr, area.size, area.flags, area.desc, area.eextend)

    return mrenclave.finalize()

SGX_SIGNING_KEY_MODULUS_LEN = 3072
SGX_SIGNING_KEY_EXPONENT = 3

class PythonSigner(object):
    def __init__(self, key_file):
        self.key_file = key_file

    # Sign the given message. Returns tuple of message and the key's modulus.
    def sign(self, message):
        with open(self.key_file, 'rb') as f:
            key = load_pem_private_key(f.read(), password=None, backend=default_backend())

        if not isinstance(key.public_key(), RSAPublicKey):
            raise RuntimeError('The specified key is not an RSA key')
        if key.key_size != SGX_SIGNING_KEY_MODULUS_LEN:
            raise RuntimeError('The specified key has a size ({}) other than {} bits'.format(
                key.key_size, SGX_SIGNING_KEY_MODULUS_LEN))
        pub = key.public_key().public_numbers()
        if pub.e != SGX_SIGNING_KEY_EXPONENT:
            raise RuntimeError('The specified key has a public exponent ({}) other than {}'.format(
                pub.e, SGX_SIGNING_KEY_EXPONENT))
        modulus = pub.n

        signature = key.sign(bytes(message), padding.PKCS1v15(), hashes.SHA256())

        return (signature, modulus)

# pub struct SignAndLogRequest<'a> {
#     pub kid : SobjectDescriptor,
#     pub build_info : &'a str,
#     pub hash: Blob,
#     pub isvprodid: i16,
#     pub plugin: Uuid,
# }

class SignAndLogRequest(object):
    def __init__(self, kid=None, build_info=None, hash=None, isvprodid=None, plugin=None):
        self._kid = kid
        self._build_info = build_info
        self._hash = hash
        self._isvprodid = isvprodid
        self._plugin = plugin

    @property
    def kid(self):
        return self._kid

    @kid.setter
    def kid(self, kid):
        self._kid = kid

    @property
    def build_info(self):
        return self._build_info

    @build_info.setter
    def build_info(self, build_info):
        self._build_info = build_info

    @property
    def hash(self):
        return self._hash

    @hash.setter
    def hash(self, hash):
        self._hash = hash

    @property
    def isvprodid(self):
        return self._isvprodid

    @isvprodid.setter
    def isvprodid(self, isvprodid):
        self._isvprodid = isvprodid

    @property
    def plugin(self):
        return self._plugin

    @plugin.setter
    def plugin(self, plugin):
        self._plugin = plugin

    def to_dict(self):
        return {
            'kid'           : self.kid,
            'build_info'    : self.build_info,
            'hash'          : self.hash,
            'isvprodid'     : self.isvprodid,
            'plugin'        : self.plugin,
        }

# req may be anything that swagger can serialize, including a swagger model
# type or a plain dict.
#
# responses are always returned as dictionaries, because that is easier than
# trying to decode the response to the appropriate data type
def execute_maybe_approve(api_client, req, req_fn, operation, method='POST'):
    try:
        resp = req_fn(api_client, req)
        if not isinstance(resp, dict):
            return resp.to_dict()
        else:
            return resp
    except ApiException as e:
        if e.body != 'This operation requires approval':
            raise

        approval_api = ApprovalRequestsApi(api_client)
        approval_req = ApprovalRequestRequest(
            body=req,
            operation=operation,
            method=method,
            description='Quorum approval request',
        )
        resp = approval_api.create_approval_request(approval_req)
        approval_req_id = resp.request_id
        while True:
            resp = approval_api.get_approval_request(approval_req_id)
            status = resp.status
            if status == ApprovalStatus.APPROVED:
                resp = approval_api.get_result(approval_req_id)
                break
            elif status == ApprovalStatus.PENDING:
                print('Approval Pending')
                time.sleep(20)
            elif status == ApprovalStatus.FAILED:
                print(approval_api.get_result(approval_req_id))
                raise RuntimeError('Request failed')
            elif status == ApprovalStatus.DENIED:
                raise RuntimeError('Request denied')
            else:
                raise RuntimeError('Unknown status {}'.format(status)())
        if resp.status != 200:
            raise RuntimeError('Operation failed: {}'.format(resp))
        return resp.body

class SdkmsSigner(object):
    def __init__(self, key_name, isvprodid, plugin_id=None, build_info=None):
        self.key_name = key_name
        self.isvprodid = isvprodid
        self.plugin_id = plugin_id
        self.build_info = build_info

    def _client(self):
        config = configuration.Configuration()
        config.verify_ssl = not os.environ.get('FORTANIX_NO_VERIFY_SSL', False)
        config.host = os.environ.get('FORTANIX_API_ENDPOINT', DEFAULT_FORTANIX_API_ENDPOINT)
        config.app_api_key = os.environ['FORTANIX_API_KEY']

        api_client = ApiClient(configuration=config)

        auth = AuthenticationApi(api_client).authorize()

        # The swagger interface calls this type of authorization an 'apiKey'.
        # This is not related to the SDKMS notion of an API key. The swagger
        # apiKey is our auth token.
        config.api_key['Authorization'] = auth.access_token
        config.api_key_prefix['Authorization'] = 'Bearer'

        return api_client

    # Sign the given message. Returns tuple of message and the key's modulus.
    def sign(self, message):
        api_client = self._client()

        # The signed data is (0..128) and (900..1028) from the sigstruct.
        # The mrenclave is located at offset 960 in the sigstruct.
        mrenclave = message[188:220]

        hasher = hashlib.sha256()
        hasher.update(message)
        digest = hasher.digest()

        sobjs = SecurityObjectsApi(api_client).get_security_objects(name=self.key_name)
        if len(sobjs) != 1:
            raise RuntimeError('Unable to retrieve signing key information from SDKMS')
        kid = sobjs[0].kid

        sobj = SecurityObjectsApi(api_client).get_security_object(kid)
        if sobj.obj_type != ObjectType.RSA:
            raise RuntimeError('The specified SDKMS key has a type ({}) other than RSA'.format(sobj.obj_type))
        if sobj.key_size != SGX_SIGNING_KEY_MODULUS_LEN:
            raise RuntimeError('The specified key has a size ({}) other than {} bits'.format(
                sobj.key_size, SGX_SIGNING_KEY_MODULUS_LEN))
        pub = load_der_public_key(bytes(sobj.pub_key), backend=default_backend()).public_numbers()
        if pub.e != SGX_SIGNING_KEY_EXPONENT:
            raise RuntimeError('The specified key has a public exponent ({}) other than {}'.format(
                pub.e, SGX_SIGNING_KEY_EXPONENT))
        modulus = pub.n

        if self.plugin_id is not None:
            final_build_info = self.build_info
            final_build_info += 'MRENCLAVE: {}\n'.format(mrenclave.hex())
            final_build_info += 'ISVPRODID: {}\n'.format(self.isvprodid)
            # SignAndLogRequest is not a fully-functional swagger model, so we
            # have to manually convert it to something the swagger client
            # knows how to serialize with to_dict().
            req = SignAndLogRequest(kid=SobjectDescriptor(kid=kid),
                                    build_info=final_build_info,
                                    hash=bytearray(digest),
                                    isvprodid=self.isvprodid,
                                    plugin=self.plugin_id).to_dict()
            resp = execute_maybe_approve(api_client, req,
                    lambda clnt, req: PluginsApi(clnt).invoke_plugin(self.plugin_id, req),
                    '/sys/v1/plugins/{}'.format(self.plugin_id))
            signature = resp['signature']

        else:
            req = SignRequest(hash=bytearray(digest), hash_alg=DigestAlgorithm.SHA256)
            resp = execute_maybe_approve(api_client, req,
                    lambda clnt, req: SignAndVerifyApi(api_client).sign(kid, req),
                    '/crypto/v1/keys/{}/sign'.format(kid))
            signature = resp['signature']

        # There are four cases to exercise in this code: (plugin, raw key)
        # crossed with (approval, no approval). In the case where we use the
        # Sign API directly and no approval is required, swagger has return
        # type information so decodes to bytearray for us. In all other cases
        # (plugin output or approvable operation output), swagger does not
        # have return type information, so gives us a base64 string.
        if not isinstance(signature, bytearray):
            signature = base64.b64decode(signature)

        return (signature, modulus)

def get_signer(cmdline_args):
    if cmdline_args.key:
        return PythonSigner(cmdline_args.key)
    elif cmdline_args.sdkms_key:
        if 'FORTANIX_API_KEY' not in os.environ:
            raise RuntimeError('You must set the FORTANIX_API_KEY environment variable to use SDKMS signing')
        if cmdline_args.build_info is not None:
            build_info = cmdline_args.build_info.read()
        else:
            build_info = ''
        return SdkmsSigner(cmdline_args.sdkms_key, cmdline_args.isvprodid, cmdline_args.plugin_id, build_info)
    else:
        raise RuntimeError('A key should have been specified on the command line')

""" Generate Sigstruct """

SIGSTRUCT_LEN = 1808

SIGSTRUCT_HEADER = (0x00000006, 0x000000e1, 0x00010000, 0x00000000)
SIGSTRUCT_VENDOR = 0
SIGSTRUCT_HEADER2 = (0x00000101, 0x00000060, 0x00000060, 0x00000001)
SIGSTRUCT_SWDEFINED = 0

def fill_sigstruct(cmdline_args, mrenclave):
    today = datetime.date.today()

    isvprodid = cmdline_args.isvprodid
    if isvprodid is None:
        isvprodid = 0
    isvsvn = cmdline_args.isvsvn
    if isvsvn is None:
        isvsvn = 0

    debug_print("ISVPRODID: %d" % (isvprodid))
    debug_print("ISVSVN:    %d" % (isvsvn))

    (attr, attrmask, xfrms,
     xfrmsmask, miscs, miscsmask) = get_enclave_attributes(cmdline_args)

    # field format: (offset, type, value)
    sigstruct = {}
    sigstruct['header']    = (   0, "<4L",  *SIGSTRUCT_HEADER)
    sigstruct['vendor']    = (  16, "<L",   SIGSTRUCT_VENDOR)
    sigstruct['date']      = (  20, "<HBB", today.year, today.month, today.day)
    sigstruct['header2']   = (  24, "<4L",  *SIGSTRUCT_HEADER2)
    sigstruct['swdefined'] = (  40, "<L",   SIGSTRUCT_SWDEFINED)

    sigstruct['miscs']     = ( 900, "4s",   miscs)
    sigstruct['miscmask']  = ( 904, "4s",   miscsmask)
    sigstruct['attrs']     = ( 928, "8s8s", attr, xfrms)
    sigstruct['attrmask']  = ( 944, "8s8s", attrmask, xfrmsmask)
    sigstruct['mrenclave'] = ( 960, "32s",  mrenclave)
    sigstruct['isvprodid'] = (1024, "<H",   isvprodid)
    sigstruct['isvsvn']    = (1026, "<H",   isvsvn)

    return sigstruct

# This modifies the sigstruct argument
def update_sigstruct(cmdline_args, sigstruct):
    today = datetime.date.today()

    if cmdline_args.isvprodid is not None:
        sigstruct['isvprodid'] = (1024, "<H", cmdline_args.isvprodid)

    if cmdline_args.isvsvn is not None:
        sigstruct['isvsvn'] = (1026, "<H", cmdline_args.isvsvn)

    (attr, attrmask, xfrms,
     xfrmsmask, miscs, miscsmask) = get_enclave_attributes(cmdline_args)

    # field format: (offset, type, value)
    sigstruct['date']      = (  20, "<HBB", today.year, today.month, today.day)

    sigstruct['miscs']     = ( 900, "4s",   miscs)
    sigstruct['miscmask']  = ( 904, "4s",   miscsmask)
    sigstruct['attrs']     = ( 928, "8s8s", attr, xfrms)
    sigstruct['attrmask']  = ( 944, "8s8s", attrmask, xfrmsmask)

    return sigstruct

def read_sigstruct(f):
    buf = f.read()
    if len(buf) != SIGSTRUCT_LEN:
        raise ValueError('Invalid sigstruct length {}'.format(len(buf)))

    fields = {}
    fields['header']    = (   0, "<4L")
    fields['vendor']    = (  16, "<L")
    fields['date']      = (  20, "<HBB")
    fields['header2']   = (  24, "<4L")
    fields['swdefined'] = (  40, "<L")

    fields['miscs']     = ( 900, "4s")
    fields['miscmask']  = ( 904, "4s")
    fields['attrs']     = ( 928, "8s8s")
    fields['attrmask']  = ( 944, "8s8s")
    fields['mrenclave'] = ( 960, "32s")
    fields['isvprodid'] = (1024, "<H")
    fields['isvsvn']    = (1026, "<H")

    sigstruct = {}
    for key, field in fields.items():
        sigstruct[key] = (*field, *struct.unpack_from(field[1], buf, offset=field[0]))

    # Check some fixed fields
    if sigstruct['header'][2:] != SIGSTRUCT_HEADER:
        raise ValueError('Invalid sigstruct header {}'.format(sigstruct['header']))
    if sigstruct['vendor'][2:] != (SIGSTRUCT_VENDOR,):
        raise ValueError('Invalid sigstruct vendor {}'.format(sigstruct['vendor']))
    if sigstruct['header2'][2:] != SIGSTRUCT_HEADER2:
        raise ValueError('Invalid sigstruct header2 {}'.format(sigstruct['header2']))
    if sigstruct['swdefined'][2:] != (SIGSTRUCT_SWDEFINED,):
        raise ValueError('Invalid sigstruct swdefined {}'.format(sigstruct['swdefined']))

    return sigstruct

# Note that this modifies the `sigstruct` argument.
def sign_sigstruct(signer, sigstruct):
    sign_buffer = bytearray(128 + 128)

    for key, field in sigstruct.items():
        if field[0] >= 900:
            struct.pack_into(field[1], sign_buffer, field[0] - 900 + 128, *field[2:])
        else:
            struct.pack_into(field[1], sign_buffer, field[0], *field[2:])

    (signature, modulus) = signer.sign(sign_buffer)

    signature_int = int.from_bytes(signature, byteorder='big')

    tmp1   = signature_int * signature_int
    q1_int = tmp1 // modulus
    tmp2   = tmp1 % modulus
    q2_int = tmp2 * signature_int // modulus

    # In the unlikely event SGX_SIGNING_KEY_MODULUS_LEN changes, this would
    # need to be updated.
    q1 = q1_int.to_bytes(384, byteorder='little')
    q2 = q2_int.to_bytes(384, byteorder='little')

    sigstruct['modulus']   = ( 128, "384s", modulus.to_bytes(384, byteorder='little'))
    sigstruct['exponent']  = ( 512, "<L",   SGX_SIGNING_KEY_EXPONENT)
    sigstruct['signature'] = ( 516, "384s", signature[::-1])

    sigstruct['q1']        = (1040, "384s", q1)
    sigstruct['q2']        = (1424, "384s", q2)

    buffer = bytearray(SIGSTRUCT_LEN)

    for key, field in sigstruct.items():
        struct.pack_into(field[1], buffer, field[0], *field[2:])

    return buffer

""" Main Program """

def parse_args():
    # Single-hyphen versions of some arguments are preserved for backwards
    # compatibility. New arguments can allow double-hyphen only.
    parser = argparse.ArgumentParser(description="Generate manifest signature")
    parser.add_argument('-output', required=True, help='Output filename')
    parser.add_argument('-libpal', help='Path to libpal shared library')
    parser.add_argument('-manifest', help='Path to manifest file')
    parser.add_argument('-exec', help='Path to executable', dest='executable')
    parser.add_argument('--isvsvn', help='Security release number', type=unsigned_short, default=None, dest='isvsvn')
    parser.add_argument('--isvprodid', help='Product id', type=unsigned_short, default=None, dest='isvprodid')
    parser.add_argument('-verbose', action='store_true',
                        help='Print verbose output during signing')
    parser.add_argument('--docker-container', '--container',
                        help='Take files from this container instead of the host (except for the manifest)')
    parser.add_argument('--buildkit-container-dir',
                        help='Directory holding files from the container filesystem that are used in the signing process')
    parser.add_argument('--keep-temp-dirs', help='Keep temporary directories instead of deleting', action='store_true')
    parser.add_argument('--plugin-id', help='UUID of SDKMS sign+log plugin')
    parser.add_argument('--build-info', help='File containing build information for SDKMS plugin signing',
                        type=argparse.FileType('r', encoding='utf-8'))
    parser.add_argument('--production', help='Sign a production enclave (ATTRIBUTES.DEBUG = 0)', action='store_true')
    parser.add_argument('--orig', help='sign a previously unsigned container (default is to re-sign a ' +
                        'container that was already signed)', action='store_true')
    parser.add_argument('--memory-model', type=str, choices = [ 'sgx1', 'sgx2', 'all' ],
                        help='Memory model to use when signing the application. Each memory model requires a ' +
                        'separate signature. The sgx1 memory model will run on sgx1 and sgx2 hardware. The sgx2 ' +
                        'memory model will only run on sgx2 memory model. Memory model all can be used to sign with ' +
                        'all available memory models.',
                        action='store')
    key_group = parser.add_mutually_exclusive_group(required=True)
    key_group.add_argument('-key', '--key', help='Path to PEM-format signing key')
    key_group.add_argument('--sdkms-key', help='Name of SDKMS signing key. FORTANIX_API_KEY must be set in the environment.')

    args = parser.parse_args()
    if args.verbose:
        global verbose
        verbose = args.verbose

    # For now, warn if a memory model is not requested. We eventually want to make the default script behavior
    # to sign with both SGX1 and SGX2 signatures, but we can't change that yet. ZIRC-4580.
    if args.memory_model is None and not args.orig:
        args.memory_model = 'sgx1'
        print('WARNING: No --memory-model option specified. The enclave will be signed with only the SGX1 ' +
              'memory layout. This default may change in future versions of enclaveos-signer. Run with '
              '--memory-model=sgx1, --memory-model=sgx2 or --memory-model=all to silence this warning '
              'and ensure compatibility with future versions of enclaveos-signer\n')

    if args.build_info and not args.plugin_id:
        raise ValueError('--build-info does not make sense without --plugin-id')

    return args

# Stand-in for the tempfile.TemporaryDirectory() class in case we want to
# preserve temporary directories after the script run.
class SavedTempDir(object):
    def __init__(self, name):
        self.name = name

    def cleanup(self):
        pass

def make_temp_dir(keep_temp_dirs):
    if keep_temp_dirs:
        ret = SavedTempDir(tempfile.mkdtemp(prefix='signer-'))
        print("Using temporary directory {}".format(ret.name))
        return ret
    else:
        return tempfile.TemporaryDirectory(prefix='signer-')

# The LocalFileReader and DockerFileReader classes provide interfaces for accessing files from the local
# filesystem and from inside a docker container, respectively.
class LocalFileReader(object):
    def __init__(self):
        pass

    def get_file(self, filename):
        return filename

    def get_runtime_path(self):
        return os.environ.get("ENCLAVEOS_RUNTIME",
                              "/opt/fortanix/enclave-os")

    def exists(self, filename):
        return os.path.exists(filename)

class DockerFileReader(object):
    def __init__(self, container, tmpdir):
        self.container = container
        self.tmpdir = tmpdir

    # TODO: We may need to support a different maximum link depth. A cursory google search indicates that
    # the maximum link depth is 40 for modern Linux kernels.
    def get_file(self, filename, maxdepth=16):
        debug_print('Reading file {} from container'.format(filename))
        origfile = filename
        while maxdepth > 0:
            maxdepth -= 1
            (fd, name) = tempfile.mkstemp(prefix='signer-', dir=self.tmpdir)
            (contents, attributes) = self.container.get_archive(filename)

            # TODO: It seems like there should be a way to do this without copying into a BytesIO.
            archive = io.BytesIO(b''.join(contents))
            archive.seek(0, io.SEEK_SET)

            tar = tarfile.open(mode='r', fileobj=archive)
            f_info = tar.getmember(os.path.basename(filename))
            if f_info.type == tarfile.REGTYPE or f_info.type == tarfile.AREGTYPE:
                debug_print('Resolved file {} as {}'.format(origfile, filename))
                f = tar.extractfile(os.path.basename(filename))
                with os.fdopen(fd, 'wb') as fh:
                    shutil.copyfileobj(f, fh)

                return name
            elif f_info.type == tarfile.SYMTYPE:
                # The file was a symbolic link. We have to resolve these ourselves.
                newfile = os.path.join(os.path.dirname(filename), f_info.linkname)
                debug_print('Resolving symlink {} -> {}'.format(filename, newfile))
                filename = newfile
                continue
            else:
                raise ValueError('Unable to read file of type {}'.format(f_info.type))
        raise ValueError('Too many symbol links trying to resolve file {}'.format(origfile))

    # When we're signing a container, the runtime files will always be in the runtime location.
    def get_runtime_path(self):
        return "/opt/fortanix/enclave-os"

    # TODO: Implement this function to actaully do something. For now, we'll fail later trying to access the
    # actual file if it does not exist.
    def exists(self, filename):
        return True

# The BuildkitContainerImageFileReader class provide interfaces for accessing files from the
# inside a buildkit container image container filesystem
class BuildkitContainerImageFileReader(object):
    def __init__(self, container_dir, tmpdir):
        self.container_dir = container_dir
        self.tmpdir = tmpdir

    def get_file(self, filename, maxdepth=16):
        assert len(filename) > 0 and filename[0] == "/"
        return os.path.join(self.container_dir, filename[1:])

    # When we're signing a container, the runtime files will always be in the runtime location.
    def get_runtime_path(self):
        return os.path.join(self.container_dir, "/opt/fortanix/enclave-os")

    # actual file if it does not exist.
    def exists(self, filename):
        assert len(filename) > 0 and filename[0] == "/"
        path = os.path.join(self.container_dir, filename[1:])
        return os.path.exists(path)

def no_signatures():
    return {
        "ENCLAVEOS_SIGNATURE": None,
        "ENCLAVEOS_SIGNATURE2": None
    }

def any_signatures(signatures):
    return (signatures["ENCLAVEOS_SIGNATURE"] is not None or
            signatures["ENCLAVEOS_SIGNATURE2"] is not None)

def sign_manifest():
    # Parse arguments
    cmdline_args = parse_args()
    docker_client = None
    container = None
    signatures = no_signatures()
    tempdir = make_temp_dir(cmdline_args.keep_temp_dirs)
    if cmdline_args.docker_container:
        docker_client = docker.from_env()
        container = docker_client.containers.create(cmdline_args.docker_container)
        reader = DockerFileReader(container, tempdir.name)
        signatures = get_sigs(container)
    # Request for manifest signing for a buildkit image with contents in a local directory
    elif cmdline_args.buildkit_container_dir:
        reader = BuildkitContainerImageFileReader(cmdline_args.buildkit_container_dir, tempdir.name)
    else:
        reader = LocalFileReader()
        container = None

    try:
        if cmdline_args.orig or container is None:
            if any_signatures(signatures):
                raise Exception('container {} already has the {} or {} environment variable set.'.format(
                    cmdline_args.docker_container, "ENCLAVEOS_SIGNATURE", "ENCLAVEOS_SIGNATURE2") +
                                'Are you converting an application that was already converted?')
            if cmdline_args.libpal is None or cmdline_args.manifest is None:
                raise ValueError('the following arguments are required for sigstruct generation: -libpal, -manifest')

            sign_manifest_helper(cmdline_args, reader, tempdir.name)
        else:
            if not any_signatures(signatures):
                raise Exception('container {} did not have an {} signature. Was this container converted?'.format(
                    cmdline_args.docker_container, "EnclaveOS"))
            sign_container(cmdline_args, docker_client, container, tempdir.name, signatures)
    finally:
        if container:
            container.remove(v=True)

def copy_libpal(tempdir, reader, libpal_path):
    copied_libpal = os.path.join(tempdir, os.path.basename(libpal_path))
    shutil.copyfile(reader.get_file(libpal_path), copied_libpal)
    return copied_libpal

def customize_libpal(copied_libpal, enclave_size, libpal_load_addr, manifest_base_addr, manifest_size, vdso_base,
                     vdso_size, shim_base, shim_size, memory_model):
    # There should be only one data segment in the PAL.
    loadcmds = get_loadcmds(copied_libpal)
    data_segment_offset = None
    data_segment_addr = None
    for (offset, addr, filesize, memsize, prot) in loadcmds:
        if (prot == 6):
            assert(data_segment_offset is None)
            data_segment_offset = offset
            data_segment_addr = addr

    assert data_segment_offset is not None

    # The enclave_parameters structure must be at the very beginning of the
    # data segment.
    with open(copied_libpal, 'rb+') as fh:
        fh.seek(data_segment_offset)
        # TODO: We don't currently have a way to pick up the structure
        # definition here from the pal-loader.h C header file. They must be
        # kept in sync manually.
        data = fh.read(0x58)
        (orig_size, orig_base, orig_pal_base, orig_manifest_base_addr, orig_manifest_size, orig_vdso_base,
         orig_vdso_size, orig_shim_base, orig_shim_size, orig_ssa_size, orig_memory_model) = \
            struct.unpack('<QQQQQQQQQQQ', data)

        # "Fortanix" in ASCII.
        magic = 0x78696e6174726f46
        assert(orig_size == magic)
        assert(orig_base == magic)
        assert(orig_pal_base == magic)
        assert(orig_manifest_base_addr == magic)
        assert(orig_manifest_size == magic)
        assert(orig_vdso_base == magic)
        assert(orig_vdso_size == magic)
        assert(orig_shim_base == magic)
        assert(orig_shim_size == magic)
        assert(orig_ssa_size == magic)
        assert(orig_memory_model == magic)

        memory_model_val = VALID_MEMORY_MODELS.index(memory_model) + 1

        fh.seek(data_segment_offset)
        enclave_base = 0
        fh.write(struct.pack('<QQQQQQQQQQQ', enclave_size + enclave_base, enclave_base, libpal_load_addr,
                             manifest_base_addr, manifest_size, vdso_base, vdso_size, shim_base, shim_size,
                             SSAFRAMESIZE, memory_model_val))

    return copied_libpal

def get_area_by_name(memory_areas, name):
    for area in memory_areas:
        if area.desc == name:
            return area

    assert(0)

def get_load_addr_by_name(memory_areas, name):
    area = get_area_by_name(memory_areas, name)
    return int(area.addr)

def get_size_by_name(memory_areas, name):
    area = get_area_by_name(memory_areas, name)
    return int(area.size)

def set_contents_by_name(memory_areas, name, contents):
    area = get_area_by_name(memory_areas, name)
    area.contents = contents

def get_vdso_path(manifest, reader):
    if 'loader.vdso' in manifest:
        vdso = manifest['loader.vdso']
        if vdso == 'none':
            return None
        if vdso.startswith('file:'):
            return reader.get_file(vdso[5:])
        else:
            raise RuntimeError('Invalid URI type for vdso: {}'.format(vdso))
    else:
        return reader.get_file(os.path.join(reader.get_runtime_path(), "bootstrap",
                                            "libenclaveos-vdso.so"))

def get_shim_path(manifest, reader):
    if 'loader.preload' in manifest:
        if manifest['loader.preload'].startswith('file:'):
            return manifest['loader.preload'][5:]
        else:
            raise RuntimeError('Invalid URI for loader.preload: {}'.format(manifest['loader.preload']))

    if 'loader.preload_shim' in manifest and not manifest['loader.preload_shim']:
        return None

    return reader.get_file(os.path.join(reader.get_runtime_path(), "bootstrap",
                                        "libenclaveos-interface.so"))

# Generate an SGX manifest, construct an SGX SIGSTRUCT, and sign it. The SGX
# manifest is based on the input manifest and adds trusted file hashes. The
# SIGSTRUCT reflects the manifest and other items loaded into the enclave
# at runtime.
#
# This routine writes the SGX manifest to a file specified with -output on
# the command line, and writes the sigstruct to a filename derived from
# the manifest name (e.g. for app.manifest.sgx, writes to app.sig).
def sign_manifest_helper(cmdline_args, reader, tempdir):
    executable = cmdline_args.executable
    (manifest, manifest_layout) = read_manifest(cmdline_args.manifest)

    if manifest and 'fs.root.uri' not in manifest and os.environ.get('SIGNER_SKIP_VALIDITY_CHECKS', '') != 'On':
        raise Exception("root uri is not specified in manifest")

    sigfile = cmdline_args.output
    for ext in ['.manifest.sgx', '.manifest']:
        if sigfile.endswith(ext):
            sigfile = sigfile[:-len(ext)]
            break
    sigfile = sigfile + '.sig'
    sigfile_sgx2 = sigfile + '2'
    manifest['sgx.sigfile'] = 'file:' + os.path.basename(sigfile)
    manifest['sgx.sigfile2'] = 'file:' + os.path.basename(sigfile_sgx2)

    # Get enclave size and thread count from manifest
    if 'sgx.enclave_size' not in manifest:
        manifest['sgx.enclave_size'] = DEFAULT_ENCLAVE_SIZE
    enclave_size = parse_size(manifest['sgx.enclave_size'])

    if 'sgx.thread_num' not in manifest:
        manifest['sgx.thread_num'] = str(DEFAULT_THREAD_NUM)
    thread_num = parse_int(manifest['sgx.thread_num'])

    if 'sgx.memory_model' not in manifest:
        manifest['sgx.memory_model'] = DEFAULT_MEMORY_MODEL
    memory_model = manifest['sgx.memory_model']
    if memory_model not in VALID_MEMORY_MODELS:
        raise Exception('Invalid memory model: ' + memory_model)

    # We added sgx-related settings to the manifest file above. Output an SGX manifest with
    # those additional options.
    output_manifest(cmdline_args.output, manifest, manifest_layout)


    for (memory_model, cur_sigfile) in [ (MEMORY_MODEL_FULL, sigfile), (MEMORY_MODEL_MINIMAL, sigfile_sgx2) ]:
        copied_pal = copy_libpal(tempdir, reader, cmdline_args.libpal)

        vdso_path = get_vdso_path(manifest, reader)
        shim_path = get_shim_path(manifest, reader)

        mrenclave = measure_enclave(memory_model, thread_num, enclave_size, copied_pal, vdso_path, shim_path, cmdline_args.output)

        debug_print("Measurement ({}):".format(cur_sigfile))
        debug_print(b"    " + binascii.hexlify(mrenclave))

        signer = get_signer(cmdline_args)
        sigstruct = fill_sigstruct(cmdline_args, mrenclave)
        open(cur_sigfile, 'wb').write(sign_sigstruct(signer, sigstruct))
    

def measure_enclave(memory_model, thread_num, enclave_size, copied_pal, vdso_path, shim_path, output):
    # Try populate memory areas
    (memory_areas, stacks) = get_memory_areas(thread_num, copied_pal, vdso_path, shim_path)

    manifest_size = os.stat(output).st_size
    memory_areas = [
            MemoryArea('manifest', file=output,
                       flags=PAGEINFO_R|PAGEINFO_REG, eextend=True)
            ] + memory_areas

    memory_areas = populate_memory_areas(memory_model, enclave_size, memory_areas)
    entry = get_entry_point(copied_pal)

    libpal_load_addr = get_load_addr_by_name(memory_areas, 'pal')
    manifest_base_addr = get_load_addr_by_name(memory_areas, 'manifest')
    tls_load_addr = get_load_addr_by_name(memory_areas, 'tls')
    ssa_load_addr = get_load_addr_by_name(memory_areas, 'ssa')

    tcs_contents = create_tcs(ssa_load_addr, tls_load_addr, libpal_load_addr, entry, thread_num)
    set_contents_by_name(memory_areas, 'tcs', tcs_contents)

    tls_contents = create_tls(tls_load_addr, stacks, ssa_load_addr, thread_num)
    set_contents_by_name(memory_areas, 'tls', tls_contents)

    if vdso_path is None:
        vdso_base = 0xffffffffffffffff
        vdso_size = 0
    else:
        vdso_base = get_load_addr_by_name(memory_areas, 'vdso')
        vdso_size = get_size_by_name(memory_areas, 'vdso')
    if shim_path is None:
        shim_base = 0xffffffffffffffff
        shim_size = 0
    else:
        shim_base = get_load_addr_by_name(memory_areas, 'shim')
        shim_size = get_size_by_name(memory_areas, 'shim')

    customize_libpal(copied_pal, enclave_size, libpal_load_addr, manifest_base_addr, manifest_size, vdso_base,
                     vdso_size, shim_base, shim_size, memory_model)

    # Generate measurement
    return generate_measurement(enclave_size, memory_areas)

# Get the signature(s) from a docker container. There are up to two signatures, one for zircon's SGX1 memory
# layout, and one for zircon's SGX2 memory layout. A container may have one or both signatures. The converter will
# by default generate both signatures, but customers can opt to re-sign with just one signature if they know they
# are only using SGX1 hardware or only using SGX2 hardware.
def get_sigs(container):
    signatures = no_signatures()
    
    if 'Env' in container.attrs['Config']:
        for var in container.attrs['Config']['Env']:
            try:
                (key, val) = var.split('=', 1)
            except ValueError:
                continue

            for env_var in signatures.keys():
                if key == env_var:
                    debug_print('Old signature for {} is {}'.format(env_var, val))
                    try:
                        sig = base64.b64decode(val)
                    except Exception:
                        raise Exception('Unable to base64 decode old signature {}'.format(val))
                    signatures[env_var] = sig

                    # Both environment variables found, bail out early.
                    if signatures["ENCLAVEOS_SIGNATURE"] and signatures["ENCLAVEOS_SIGNATURE2"]:
                        return signatures

    return signatures


# Read an existing SIGSTRUCT from a container, resign it, and build a new
# docker image with the new signature. This is useful for applying
# production signatures to images.
#
# Note that unlike sign_manifest_helper, output in this case is a docker
# image held by the local docker daemon.
def sign_container(cmdline_args, docker_client, container, temp_dir, signatures):
    use_buildkit = False

    if cmdline_args.memory_model == 'sgx1':
        need_sigs = [ "ENCLAVEOS_SIGNATURE" ]
        unneeded_sigs = [ "ENCLAVEOS_SIGNATURE2" ]
    elif cmdline_args.memory_model == 'sgx2':
        need_sigs = [ "ENCLAVEOS_SIGNATURE2" ]
        unneeded_sigs = [ "ENCLAVEOS_SIGNATURE" ]
    elif cmdline_args.memory_model == 'all':
        need_sigs = [ "ENCLAVEOS_SIGNATURE", "ENCLAVEOS_SIGNATURE2" ]
        unneeded_sigs = [ ]
    else:
        raise Exception('Unknown requested memory model: "{}"'.format(cmdline_args.memory_model))

    for env_name in need_sigs:
        if signatures[env_name] is None:
            raise ValueError('Container does not have the {} environment variable. '.format(env_name) +
                             'The container must already have an existing signature to re-sign')
    
    with open(os.path.join(temp_dir, 'Dockerfile') ,'wb') as file:
        file.write(('FROM {}\n'.format(cmdline_args.docker_container)).encode('utf-8'))

        for env_name in need_sigs:
            sigstruct = read_sigstruct(io.BytesIO(signatures[env_name]))

            # Modifies the sigstruct argument based on cmdline args
            update_sigstruct(cmdline_args, sigstruct)

            signer = get_signer(cmdline_args)
            newsig = sign_sigstruct(signer, sigstruct)

            file.write('ENV {} "{}"\n'.format(env_name, base64.b64encode(newsig).decode('utf-8')).encode('utf-8'))

        # To avoid confusion, if it was requested that we sign with just an SGX1 or just an SGX2 signature, we
        # drop the other signature.   
        for env_name in unneeded_sigs:
            file.write('ENV {} ""\n'.format(env_name).encode('utf-8'))

    # Possibly confusing: the "-output" command-line argument to the script is a file name when signing for
    # the first time, but a docker repository specifier (with required remote repository) when re-signing
    # an application. So if the script gets invoked in the wrong way, it can lead to us trying to parse a file
    # path as a docker registry name, which might not work. So throw a more informative exception if the
    # parsing fails. MAL-3134 / ZIRC-4572.
    match = IMAGE_REGEX.match(cmdline_args.output)
    if match is None or len(match.groups()) != 2:
        raise Exception('Unable to parse docker repository specifier "{}"'.format(cmdline_args.output))
    (repo, tag) = match.groups()

    # Using the 'buildkit' for building the output image, this logic is inactive and not tested
    if use_buildkit:
        # Buildkit deamon socket
        ip = os.environ['BUILDKIT_IP']
        port = os.environ['BUILDKIT_TCP_PORT']
        buildkit_host = "tcp://" + ip + ":" + port
        # Building the new image with the production signature using buildkit
        # Todo: does production signing requests image need credentials for pulling?
        buildkit_cmd = ["buildctl", "--addr", buildkit_host, "build", "--progress", "plain", "--frontend=dockerfile.v0",
                        "--local", "context={}".format(temp_dir), "--local", "dockerfile={}".format(temp_dir),
                        "--output", "type=docker,name={}:{}".format(repo, tag)]
        buildkit_op = subprocess.check_output(buildkit_cmd)
    # Using the 'docker' for building the output image
    else:
        dockerfile = open(os.path.join(temp_dir, 'Dockerfile') ,'rb')
        (final_image, _) = docker_client.images.build(fileobj=dockerfile, rm=True)
        final_image.tag(repo, tag)
if __name__ == "__main__":
    sign_manifest()
